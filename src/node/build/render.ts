import type { Rollup } from "vite";
import type { SiteConfig } from "../siteConfig";
import type { PageData, SSGContext } from "../../client/shared";

import path from "node:path";
import { pathToFileURL } from "node:url";
import fs from "fs-extra";
import { normalizePath, transformWithEsbuild } from "vite";
import { isBooleanAttr } from "@vue/shared";
import { escapeHtml, sanitizeFileName, slash } from "../../client/shared";
import { EXTERNAL_URL_RE } from "../../client/shared";

export type HeadConfig =
  | [string, Record<string, string>]
  | [string, Record<string, string>, string];

export async function renderPage(
  render: (path: string) => Promise<SSGContext>,
  config: SiteConfig,
  page: string,
  result: Rollup.RollupOutput | null,
  appChunk: Rollup.OutputChunk | null,
  cssChunk: Rollup.OutputAsset | null,
  assets: string[],
  pageToHashMap: Record<string, string>,
  metadataScript: { html: string; inHead: boolean },
  additionalHeadTags: HeadConfig[]
): Promise<void> {
  const routePath = `/${page.replace(/\/?page\.(js|jsx|ts|tsx|vue)$/, "")}`;

  const { content, teleports } = await render(routePath);

  const pageName = sanitizeFileName(
    page.slice(0, -path.extname(page).length).replaceAll("/", "_")
  );
  const pageServerJsFileName = pageName + ".js";
  const pageHash = pageToHashMap[pageName.toLowerCase()];
  const pageClientJsFileName = `assets/${pageName}.${pageHash}.js`;

  let pageData: PageData;

  try {
    const { __pageData } = await import(
      pathToFileURL(path.join(config.tempDir, pageServerJsFileName)).href
    );
    pageData = __pageData;
  } catch (e) {
    throw e;
  }

  const stylesheetLink = cssChunk
    ? `<link rel="preload stylesheet" href="${config.basePath}${cssChunk.fileName}" as="style">`
    : "";

  let preloadLinks =
    result && appChunk
      ? [
          ...new Set([
            ...resolvePageImports(config, page, result, appChunk),
            pageClientJsFileName,
          ]),
        ]
      : [];
  let prefetchLinks: string[] = [];

  const toHeadTags = (files: string[], rel: string): HeadConfig[] =>
    files.map((file) => [
      "link",
      { rel, href: (EXTERNAL_URL_RE.test(file) ? "" : config.basePath) + file },
    ]);

  const preloadHeadTags = toHeadTags(preloadLinks, "modulepreload");
  const prefetchHeadTags = toHeadTags(prefetchLinks, "prefetch");

  const headBeforeTransform = [
    ...additionalHeadTags,
    ...preloadHeadTags,
    ...prefetchHeadTags,
  ];

  const head = headBeforeTransform;

  const html = `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    ${stylesheetLink}
    ${metadataScript.inHead ? metadataScript.html : ""}
    ${appChunk ? `<script type="module" src="${config.basePath}${appChunk.fileName}"></script>` : ""}
    ${await renderHead(head)}
  </head>
  <body>${teleports?.body || ""}
    <div id="app">${content}</div>
    ${metadataScript.inHead ? "" : metadataScript.html}
  </body>
</html>`;

  const htmlFileName = path.join(
    config.distDir,
    `${routePath === "/" ? "/index" : routePath}.html`
  );
  await fs.ensureDir(path.dirname(htmlFileName));
  await fs.writeFile(htmlFileName, html);
}

function resolvePageImports(
  config: SiteConfig,
  page: string,
  result: Rollup.RollupOutput,
  appChunk: Rollup.OutputChunk
): string[] {
  // find the page's js chunk and inject script tags for its imports so that
  // they start fetching as early as possible
  let srcPath = path.resolve(config.root, "pages", page);
  try {
    if (!config.vite?.resolve?.preserveSymlinks) {
      srcPath = fs.realpathSync(srcPath);
    }
  } catch (e) {
    // if the page is a virtual page generated by a dynamic route this would
    // fail, which is expected
  }
  srcPath = normalizePath(srcPath).replace(/page\.(jsx|ts|tsx|vue)/, "page.js");
  const pageChunk = result.output.find(
    (chunk) =>
      chunk.type === "chunk" &&
      chunk.facadeModuleId !== null &&
      slash(chunk.facadeModuleId) === srcPath
  ) as Rollup.OutputChunk;

  return [
    ...appChunk.imports,
    ...appChunk.dynamicImports,
    ...pageChunk.imports,
    ...pageChunk.dynamicImports,
  ];
}

async function renderHead(head: HeadConfig[]): Promise<string> {
  const tags = await Promise.all(
    head.map(async ([tag, attrs = {}, innerHTML = ""]) => {
      const openTag = `<${tag}${renderAttrs(attrs)}>`;
      if (tag !== "link" && tag !== "meta") {
        if (
          tag === "script" &&
          (attrs.type === undefined || attrs.type.includes("javascript"))
        ) {
          innerHTML = (
            await transformWithEsbuild(innerHTML, "inline-script.js", {
              minify: false,
            })
          ).code.trim();
        }
        return `${openTag}${innerHTML}</${tag}>`;
      }
      return openTag;
    })
  );
  return tags.join("\n    ");
}

function renderAttrs(attrs: Record<string, string>): string {
  return Object.keys(attrs)
    .map((key) => {
      if (isBooleanAttr(key)) return ` ${key}`;
      return ` ${key}="${escapeHtml(attrs[key])}"`;
    })
    .join("");
}
